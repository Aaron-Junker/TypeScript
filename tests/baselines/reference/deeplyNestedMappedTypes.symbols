//// [tests/cases/compiler/deeplyNestedMappedTypes.ts] ////

=== deeplyNestedMappedTypes.ts ===
// Simplified repro from #55535

type Id<T> = { [K in keyof T]: Id<T[K]> };
>Id : Symbol(Id, Decl(deeplyNestedMappedTypes.ts, 0, 0))
>T : Symbol(T, Decl(deeplyNestedMappedTypes.ts, 2, 8))
>K : Symbol(K, Decl(deeplyNestedMappedTypes.ts, 2, 16))
>T : Symbol(T, Decl(deeplyNestedMappedTypes.ts, 2, 8))
>Id : Symbol(Id, Decl(deeplyNestedMappedTypes.ts, 0, 0))
>T : Symbol(T, Decl(deeplyNestedMappedTypes.ts, 2, 8))
>K : Symbol(K, Decl(deeplyNestedMappedTypes.ts, 2, 16))

type Foo1 = Id<{ x: { y: { z: { a: { b: { c: number } } } } } }>;
>Foo1 : Symbol(Foo1, Decl(deeplyNestedMappedTypes.ts, 2, 42))
>Id : Symbol(Id, Decl(deeplyNestedMappedTypes.ts, 0, 0))
>x : Symbol(x, Decl(deeplyNestedMappedTypes.ts, 4, 16))
>y : Symbol(y, Decl(deeplyNestedMappedTypes.ts, 4, 21))
>z : Symbol(z, Decl(deeplyNestedMappedTypes.ts, 4, 26))
>a : Symbol(a, Decl(deeplyNestedMappedTypes.ts, 4, 31))
>b : Symbol(b, Decl(deeplyNestedMappedTypes.ts, 4, 36))
>c : Symbol(c, Decl(deeplyNestedMappedTypes.ts, 4, 41))

type Foo2 = Id<{ x: { y: { z: { a: { b: { c: string } } } } } }>;
>Foo2 : Symbol(Foo2, Decl(deeplyNestedMappedTypes.ts, 4, 65))
>Id : Symbol(Id, Decl(deeplyNestedMappedTypes.ts, 0, 0))
>x : Symbol(x, Decl(deeplyNestedMappedTypes.ts, 5, 16))
>y : Symbol(y, Decl(deeplyNestedMappedTypes.ts, 5, 21))
>z : Symbol(z, Decl(deeplyNestedMappedTypes.ts, 5, 26))
>a : Symbol(a, Decl(deeplyNestedMappedTypes.ts, 5, 31))
>b : Symbol(b, Decl(deeplyNestedMappedTypes.ts, 5, 36))
>c : Symbol(c, Decl(deeplyNestedMappedTypes.ts, 5, 41))

declare const foo1: Foo1;
>foo1 : Symbol(foo1, Decl(deeplyNestedMappedTypes.ts, 7, 13))
>Foo1 : Symbol(Foo1, Decl(deeplyNestedMappedTypes.ts, 2, 42))

const foo2: Foo2 = foo1;  // Error expected
>foo2 : Symbol(foo2, Decl(deeplyNestedMappedTypes.ts, 8, 5))
>Foo2 : Symbol(Foo2, Decl(deeplyNestedMappedTypes.ts, 4, 65))
>foo1 : Symbol(foo1, Decl(deeplyNestedMappedTypes.ts, 7, 13))

// Repro from issue linked in #55535

type RequiredDeep<T> = { [K in keyof T]-?: RequiredDeep<T[K]> };
>RequiredDeep : Symbol(RequiredDeep, Decl(deeplyNestedMappedTypes.ts, 8, 24))
>T : Symbol(T, Decl(deeplyNestedMappedTypes.ts, 12, 18))
>K : Symbol(K, Decl(deeplyNestedMappedTypes.ts, 12, 26))
>T : Symbol(T, Decl(deeplyNestedMappedTypes.ts, 12, 18))
>RequiredDeep : Symbol(RequiredDeep, Decl(deeplyNestedMappedTypes.ts, 8, 24))
>T : Symbol(T, Decl(deeplyNestedMappedTypes.ts, 12, 18))
>K : Symbol(K, Decl(deeplyNestedMappedTypes.ts, 12, 26))

type A = { a?: { b: { c: 1 | { d: 2000 } }}}
>A : Symbol(A, Decl(deeplyNestedMappedTypes.ts, 12, 64))
>a : Symbol(a, Decl(deeplyNestedMappedTypes.ts, 14, 10))
>b : Symbol(b, Decl(deeplyNestedMappedTypes.ts, 14, 16))
>c : Symbol(c, Decl(deeplyNestedMappedTypes.ts, 14, 21))
>d : Symbol(d, Decl(deeplyNestedMappedTypes.ts, 14, 30))

type B = { a?: { b: { c: { d: { e: { f: { g: 2 }}}}, x: 1000 }}}
>B : Symbol(B, Decl(deeplyNestedMappedTypes.ts, 14, 44))
>a : Symbol(a, Decl(deeplyNestedMappedTypes.ts, 15, 10))
>b : Symbol(b, Decl(deeplyNestedMappedTypes.ts, 15, 16))
>c : Symbol(c, Decl(deeplyNestedMappedTypes.ts, 15, 21))
>d : Symbol(d, Decl(deeplyNestedMappedTypes.ts, 15, 26))
>e : Symbol(e, Decl(deeplyNestedMappedTypes.ts, 15, 31))
>f : Symbol(f, Decl(deeplyNestedMappedTypes.ts, 15, 36))
>g : Symbol(g, Decl(deeplyNestedMappedTypes.ts, 15, 41))
>x : Symbol(x, Decl(deeplyNestedMappedTypes.ts, 15, 52))

type C = RequiredDeep<A>;
>C : Symbol(C, Decl(deeplyNestedMappedTypes.ts, 15, 64))
>RequiredDeep : Symbol(RequiredDeep, Decl(deeplyNestedMappedTypes.ts, 8, 24))
>A : Symbol(A, Decl(deeplyNestedMappedTypes.ts, 12, 64))

type D = RequiredDeep<B>;
>D : Symbol(D, Decl(deeplyNestedMappedTypes.ts, 17, 25))
>RequiredDeep : Symbol(RequiredDeep, Decl(deeplyNestedMappedTypes.ts, 8, 24))
>B : Symbol(B, Decl(deeplyNestedMappedTypes.ts, 14, 44))

type Test1 = [C, D] extends [D, C] ? true : false;  // false
>Test1 : Symbol(Test1, Decl(deeplyNestedMappedTypes.ts, 18, 25))
>C : Symbol(C, Decl(deeplyNestedMappedTypes.ts, 15, 64))
>D : Symbol(D, Decl(deeplyNestedMappedTypes.ts, 17, 25))
>D : Symbol(D, Decl(deeplyNestedMappedTypes.ts, 17, 25))
>C : Symbol(C, Decl(deeplyNestedMappedTypes.ts, 15, 64))

type Test2 = C extends D ? true : false;  // false
>Test2 : Symbol(Test2, Decl(deeplyNestedMappedTypes.ts, 20, 50))
>C : Symbol(C, Decl(deeplyNestedMappedTypes.ts, 15, 64))
>D : Symbol(D, Decl(deeplyNestedMappedTypes.ts, 17, 25))

type Test3 = D extends C ? true : false;  // false
>Test3 : Symbol(Test3, Decl(deeplyNestedMappedTypes.ts, 21, 40))
>D : Symbol(D, Decl(deeplyNestedMappedTypes.ts, 17, 25))
>C : Symbol(C, Decl(deeplyNestedMappedTypes.ts, 15, 64))

// Simplified repro from #54246

// Except for the final non-recursive Record<K, V>, object types produced by NestedRecord all have the same symbol
// and thus are considered deeply nested after three levels of nesting. Ideally we'd detect that recursion in this
// type always terminates, but we're unaware of a general algorithm that accomplishes this.

type NestedRecord<K extends string, V> = K extends `${infer K0}.${infer KR}` ? { [P in K0]: NestedRecord<KR, V> } : Record<K, V>;
>NestedRecord : Symbol(NestedRecord, Decl(deeplyNestedMappedTypes.ts, 22, 40))
>K : Symbol(K, Decl(deeplyNestedMappedTypes.ts, 30, 18))
>V : Symbol(V, Decl(deeplyNestedMappedTypes.ts, 30, 35))
>K : Symbol(K, Decl(deeplyNestedMappedTypes.ts, 30, 18))
>K0 : Symbol(K0, Decl(deeplyNestedMappedTypes.ts, 30, 59))
>KR : Symbol(KR, Decl(deeplyNestedMappedTypes.ts, 30, 71))
>P : Symbol(P, Decl(deeplyNestedMappedTypes.ts, 30, 82))
>K0 : Symbol(K0, Decl(deeplyNestedMappedTypes.ts, 30, 59))
>NestedRecord : Symbol(NestedRecord, Decl(deeplyNestedMappedTypes.ts, 22, 40))
>KR : Symbol(KR, Decl(deeplyNestedMappedTypes.ts, 30, 71))
>V : Symbol(V, Decl(deeplyNestedMappedTypes.ts, 30, 35))
>Record : Symbol(Record, Decl(lib.es5.d.ts, --, --))
>K : Symbol(K, Decl(deeplyNestedMappedTypes.ts, 30, 18))
>V : Symbol(V, Decl(deeplyNestedMappedTypes.ts, 30, 35))

type Bar1 = NestedRecord<"x.y.z.a.b.c", number>;
>Bar1 : Symbol(Bar1, Decl(deeplyNestedMappedTypes.ts, 30, 129))
>NestedRecord : Symbol(NestedRecord, Decl(deeplyNestedMappedTypes.ts, 22, 40))

type Bar2 = NestedRecord<"x.y.z.a.b.c", string>;
>Bar2 : Symbol(Bar2, Decl(deeplyNestedMappedTypes.ts, 32, 48))
>NestedRecord : Symbol(NestedRecord, Decl(deeplyNestedMappedTypes.ts, 22, 40))

declare const bar1: Bar1;
>bar1 : Symbol(bar1, Decl(deeplyNestedMappedTypes.ts, 35, 13))
>Bar1 : Symbol(Bar1, Decl(deeplyNestedMappedTypes.ts, 30, 129))

const bar2: Bar2 = bar1;  // Error expected
>bar2 : Symbol(bar2, Decl(deeplyNestedMappedTypes.ts, 36, 5))
>Bar2 : Symbol(Bar2, Decl(deeplyNestedMappedTypes.ts, 32, 48))
>bar1 : Symbol(bar1, Decl(deeplyNestedMappedTypes.ts, 35, 13))

